"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.Events = void 0;

const events_1 = require("events");

const consts_1 = require("../consts");

const utils_1 = require("../utils");

const utils_2 = require("../utils");

class Events {
  constructor(client) {
    this._client = client;
  }

  onReady(fn) {
    this._client.on("ready", fn);
  }

  async onceReady() {
    await this._once("ready");
    return;
  }

  onMessageReactionRemoveEmoji(fn) {
    this._client.on("messageReactionRemoveEmoji", fn);
  }

  onceMessageReactionRemoveEmoji() {
    return this._once("messageReactionRemoveEmoji");
  }

  onChannelCreate(fn) {
    this._client.on("channelCreate", fn);
  }

  onceChannelCreate() {
    return this._once("channelCreate");
  }

  onChannelDelete(fn) {
    this._client.on("channelDelete", fn);
  }

  onceChannelDelete() {
    return this._once("channelDelete");
  }

  onChannelPinsUpdate(fn) {
    this._client.on("channelPinsUpdate", fn);
  }

  async onceChannelPinsUpdate() {
    return this._once("channelPinsUpdate");
  }

  onChannelUpdate(fn) {
    this._client.on("channelUpdate", fn);
  }

  async onceChannelUpdate() {
    return this._once("channelUpdate");
  }

  onDebug(fn) {
    this._client.on("debug", fn);
  }

  async onceDebug() {
    return await this._once("debug");
  }

  onRoleDelete(fn) {
    this._client.on("roleDelete", fn);
  }

  onceRoleDelete(roleIdentifier, timeout, guildId) {
    const validator = new utils_2.Validator();

    if (roleIdentifier) {
      validator.add((role) => this.roleMatchRoleData(roleIdentifier, role));
    }

    if (guildId) {
      validator.add((role) => role.guild.id === guildId);
    }

    return utils_1.executePromiseWithTimeout((resolve) => {
      this.onRoleDelete((deletedRole) => {
        if (validator.isValid(deletedRole)) {
          resolve(deletedRole);
        }
      });
    }, timeout);
  }

  onDisconnect(fn) {
    this._client.on("disconnect", fn);
  }

  onceDisconnect() {
    return this._once("disconnect");
  }

  onEmojiCreate(fn) {
    this._client.on("emojiCreate", fn);
  }

  onceEmojiCreate() {
    return this._once("emojiCreate");
  }

  onEmojiDelete(fn) {
    this._client.on("emojiDelete", fn);
  }

  onceEmojiDelete() {
    return this._once("emojiDelete");
  }

  onEmojiUpdate(fn) {
    this._client.on("emojiUpdate", fn);
  }

  onceEmojiUpdate() {
    return this._once("emojiUpdate");
  }

  onError(fn) {
    this._client.on("error", fn);
  }

  onceError() {
    return this._once("error");
  }

  onGuildBan(fn) {
    this._client.on("guildBanAdd", fn);
  }

  onceGuildBan() {
    return this._once("guildBanAdd");
  }

  onGuildBanRemove(fn) {
    this._client.on("guildBanRemove", fn);
  }

  onceGuildBanRemove() {
    return this._once("guildBanRemove");
  }

  onGuildCreate(fn) {
    this._client.on("guildCreate", fn);
  }

  onceGuildCreate() {
    return this._once("guildCreate");
  }

  onGuildDelete(fn) {
    this._client.on("guildDelete", fn);
  }

  onceGuildDelete() {
    return this._once("guildDelete");
  }

  onGuildMemberAdd(fn) {
    this._client.on("guildMemberAdd", fn);
  }

  onceGuildMemberAdd() {
    return this._once("guildMemberAdd");
  }

  onGuildMemberAvailable(fn) {
    this._client.on("guildMemberAvailable", fn);
  }

  onceGuildMemberAvailable() {
    return this._once("guildMemberAvailable");
  }

  onGuildMemberRemove(fn) {
    this._client.on("guildMemberRemove", fn);
  }

  onceGuildMemberRemove() {
    return this._once("guildMemberRemove");
  }

  onGuildMemberChunk(fn) {
    this._client.on("guildMembersChunk", fn);
  }

  onceGuildMemberChunk() {
    return this._once("guildMembersChunk");
  }

  onGuildMemberSpeaking(fn) {
    this._client.on("guildMemberSpeaking", fn);
  }

  onceGuildMemberSpeaking() {
    return this._once("guildMemberSpeaking");
  }

  onGuildMemberUpdate(fn) {
    this._client.on("guildMemberUpdate", fn);
  }

  onceGuildMemberUpdate() {
    return this._once("guildMemberUpdate");
  }

  onGuildUnavailable(fn) {
    this._client.on("guildUnavailable", fn);
  }

  onceGuildUnavailable() {
    return this._once("guildUnavailable");
  }

  onGuildUpdate(fn) {
    this._client.on("guildUpdate", fn);
  }

  onceGuildUpdate() {
    return this._once("guildUpdate");
  }

  onMessage(fn) {
    this._client.on("message", fn);
  }

  onceMessage(authorId, channelId, timeout) {
    const validator = new utils_2.Validator();

    if (authorId) {
      validator.add((mgs) => mgs.author.id === authorId);
    }

    if (channelId) {
      validator.add((mgs) => mgs.channel.id === channelId);
    }

    return utils_1.executePromiseWithTimeout((resolve) => {
      this.onMessage((message) => {
        if (validator.isValid(message)) {
          resolve(message);
        }
      });
    }, timeout);
  }

  onMessageDelete(fn) {
    this._client.on("messageDelete", fn);
  }

  onceMessageDelete() {
    return this._once("messageDelete");
  }

  onMessageDeleteBulk(fn) {
    this._client.on("messageDeleteBulk", fn);
  }

  onceMessageDeleteBulk() {
    return this._once("messageDeleteBulk");
  }

  onMessageReactionAdd(fn) {
    this._client.on("messageReactionAdd", fn);
  }

  onceMessageReactionAdd() {
    return this._once("messageReactionAdd");
  }

  onceMessageReactionsAdd(filter) {
    return this._onceMessageReactionUpdate("onMessageReactionAdd", filter);
  }

  onceMessageReactionsRemove(filter) {
    return this._onceMessageReactionUpdate("onMessageReactionRemoveEmoji", filter);
  }

  _onceMessageReactionUpdate(event, filter) {
    const { emojis, messageIdentifier, authorId, timeout, channelId } = filter ?? {};
    const validator = new utils_2.Validator();

    if (emojis) {
      validator.add((reaction) =>
        emojis.some((e) => e.id === reaction.emoji.id || e.name === reaction.emoji.name),
      );
    }

    if (channelId) {
      validator.add((reaction) => reaction.message.channel.id === channelId);
    }

    if (messageIdentifier) {
      validator.add(
        ({ message }) =>
          message.id === messageIdentifier.id || message.content === messageIdentifier.content,
      );
    }

    if (authorId) {
      validator.add((_, author) => !author || author.id === authorId);
    }

    const response = [];
    return utils_1.executePromiseWithTimeout(
      (resolve) => {
        this[event]((reaction, author) => {
          if (validator.isValid(reaction, author)) {
            response.push([reaction, author]);
          }

          if (!emojis && !authorId && !messageIdentifier) {
            resolve(response);
          }

          if (response.length === (emojis === null || emojis === void 0 ? void 0 : emojis.length)) {
            resolve(response);
          }
        });
      },
      timeout,
      response,
    );
  }

  onMessageReactionRemove(fn) {
    this._client.on("messageReactionRemove", fn);
  }

  onceMessageReactionRemove() {
    return this._once("messageReactionRemove");
  }

  onMessageReactionRemoveAll(fn) {
    this._client.on("messageReactionRemoveAll", fn);
  }

  onceMessageReactionRemoveAll() {
    return this._once("messageReactionRemoveAll");
  }

  onMessageUpdate(fn) {
    this._client.on("messageUpdate", fn);
  }

  onceMessageUpdate() {
    return this._once("messageUpdate");
  }

  onceMessagePinned(messageIdentifier, timeout, channelId) {
    return this._onceMessageSetPinneble(
      (oldMessage, newMessage) => !oldMessage.pinned && newMessage.pinned,
      messageIdentifier,
      timeout,
      channelId,
    );
  }

  onceMessageUnPinned(messageIdentifier, timeout, channelId) {
    return this._onceMessageSetPinneble(
      (oldMessage, newMessage) => oldMessage.pinned && !newMessage.pinned,
      messageIdentifier,
      timeout,
      channelId,
    );
  }

  _onceMessageSetPinneble(validation, messageIdentifier, timeout, channelId) {
    const validator = new utils_2.Validator();
    validator.add(validation);

    if (messageIdentifier) {
      validator.add(
        (oldMessage) =>
          oldMessage.id === messageIdentifier.id ||
          oldMessage.content === messageIdentifier.content,
      );
    }

    if (channelId) {
      validator.add((message) => message.channel.id === channelId);
    }

    return utils_1.executePromiseWithTimeout((resolve) => {
      this.onMessageUpdate((oldMessage, newMessage) => {
        if (validator.isValid(oldMessage, newMessage)) {
          resolve(newMessage);
        }
      });
    }, timeout);
  }

  onceMessageContentOrEmbedChange(messageIdentifier, timeout, channelId) {
    const validator = new utils_2.Validator();
    validator.add(
      (oldMessage, newMessage) =>
        oldMessage.content != newMessage.content ||
        this.messagesHasDifferentsEmbeds(oldMessage, newMessage),
    );

    if (messageIdentifier) {
      validator.add(
        (oldMessage) =>
          oldMessage.id === messageIdentifier.id ||
          oldMessage.content === messageIdentifier.content,
      );
    }

    if (channelId) {
      validator.add((message) => message.channel.id === channelId);
    }

    return utils_1.executePromiseWithTimeout((resolve) => {
      this.onMessageUpdate((oldMessage, newMessage) => {
        if (validator.isValid(oldMessage, newMessage)) {
          resolve(newMessage);
        }
      });
    }, timeout);
  }

  messagesHasDifferentsEmbeds(oldMessage, newMessage) {
    return !utils_1.deepEqual(oldMessage.embeds, newMessage.embeds);
  }

  onPresenceUpdate(fn) {
    this._client.on("presenceUpdate", fn);
  }

  oncePresenceUpdate() {
    return this._once("presenceUpdate");
  }

  onRoleCreate(fn) {
    this._client.on("roleCreate", fn);
  }

  onceRoleCreate() {
    return this._once("roleCreate");
  }

  onRoleUpdate(fn) {
    this._client.on("roleUpdate", fn);
  }

  onceRoleUpdate() {
    return this._once("roleUpdate");
  }

  onceRoleRenamed(roleIdentifier, timeout, guildId) {
    return this._onRoleUpdateWithTimeout(
      (oldRole, newRole) => oldRole.name !== newRole.name,
      timeout,
      roleIdentifier,
      guildId,
    );
  }

  onceRolePositionUpdate(roleIdentifier, timeout, guildId) {
    return this._onRoleUpdateWithTimeout(
      (oldRole, newRole) => oldRole.rawPosition !== newRole.rawPosition,
      timeout,
      roleIdentifier,
      guildId,
    );
  }

  onceRoleUpdateColor(roleIdentifier, timeout, guildId) {
    return this._onRoleUpdateWithTimeout(
      (oldRole, newRole) => oldRole.color !== newRole.color,
      timeout,
      roleIdentifier,
      guildId,
    );
  }

  onceRoleHoistUpdate(roleIdentifier, timeout, guildId) {
    return this._onRoleUpdateWithTimeout(
      (oldRole, newRole) => oldRole.hoist !== newRole.hoist,
      timeout,
      roleIdentifier,
      guildId,
    );
  }

  onceRoleMentionableUpdate(roleIdentifier, timeout, guildId) {
    return this._onRoleUpdateWithTimeout(
      (oldRole, newRole) => oldRole.mentionable !== newRole.mentionable,
      timeout,
      roleIdentifier,
      guildId,
    );
  }

  onceRolePermissionUpdate(roleIdentifier, timeout = consts_1.DEFAULT_TEST_TIMEOUT, guildId) {
    const validator = new utils_2.Validator();
    validator.add((_, newRole) => this.roleMatchRoleData(roleIdentifier, newRole));

    if (guildId) {
      validator.add((newRole) => newRole.guild.id === guildId);
    }

    return utils_1.executePromiseWithTimeout((resolve) => {
      this.onRoleUpdate((oldRole, newRole) => {
        if (validator.isValid(oldRole, newRole)) {
          resolve(newRole);
        }
      });
    }, timeout);
  }

  roleMatchRoleData(roleIdentifier, role) {
    return (
      role.id ===
        (roleIdentifier === null || roleIdentifier === void 0 ? void 0 : roleIdentifier.id) ||
      role.name ===
        (roleIdentifier === null || roleIdentifier === void 0 ? void 0 : roleIdentifier.name)
    );
  }

  rolesPermissionsMatch(oldRole, newRole) {
    return oldRole.permissions.equals(newRole.permissions);
  }

  onTypingStart(fn) {
    this._client.on("typingStart", fn);
  }

  onceTypingStart() {
    return this._once("typingStart");
  }

  onUserUpdate(fn) {
    this._client.on("userUpdate", fn);
  }

  onceUserUpdate() {
    return this._once("userUpdate");
  }

  onVoiceStateUpdate(fn) {
    this._client.on("voiceStateUpdate", fn);
  }

  onceVoiceStateUpdate() {
    return this._once("voiceStateUpdate");
  }

  async _once(event) {
    const response = await events_1.once(this._client, event);

    if (response.length === 1) {
      return response[0];
    }

    return response;
  }

  _onRoleUpdateWithTimeout(comparable, timeout, roleIdentifier, guildId) {
    const validator = new utils_2.Validator();
    validator.add((oldRole, newRole) => comparable(oldRole, newRole));

    if (roleIdentifier) {
      validator.add((_, newRole) => this.roleMatchRoleData(roleIdentifier, newRole));
    }

    if (guildId) {
      validator.add((role) => role.guild.id === guildId);
    }

    return utils_1.executePromiseWithTimeout((resolve) => {
      this.onRoleUpdate((oldRole, newRole) => {
        if (validator.isValid(oldRole, newRole)) {
          resolve(newRole);
        }
      });
    }, timeout);
  }
}

exports.Events = Events;

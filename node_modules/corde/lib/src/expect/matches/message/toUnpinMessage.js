"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.ToUnPinMessage = void 0;

const utils_1 = require("../../../utils");

const messageExpectTest_1 = require("./messageExpectTest");

class ToUnPinMessage extends messageExpectTest_1.MessageExpectTest {
  constructor(params) {
    super({ ...params, testName: "toUnPinMessage" });
  }

  async action(messageIdentifier) {
    if (
      !messageIdentifier ||
      (utils_1.typeOf(messageIdentifier) !== "string" &&
        utils_1.typeOf(messageIdentifier) !== "object")
    ) {
      return this.createReport(
        "expected: message identifier to be a string or a IMessageIdentifier object\n",
        `received: ${utils_1.typeOf(messageIdentifier)}`,
      );
    }

    let _msgIdentifier;

    if (typeof messageIdentifier === "string") {
      _msgIdentifier = {
        id: messageIdentifier,
      };
    } else {
      _msgIdentifier = messageIdentifier;
    }

    try {
      await this.sendCommandMessage();
    } catch (error) {
      return this.createFailedTest(error.message);
    }

    const msgString = this.humanizeMessageIdentifierObject(_msgIdentifier);

    try {
      await this.cordeBot.events.onceMessageUnPinned(_msgIdentifier, this.timeOut, this.channelId);
    } catch {
      if (this.isNot) {
        return this.createPassTest();
      }

      return this.createReport(
        `expected: unpin ${msgString}\n`,
        "received: informed message was not unpinned",
      );
    }

    this.hasPassed = true;
    this.invertHasPassedIfIsNot();

    if (this.hasPassed) {
      return this.createPassTest();
    }

    return this.createReport(
      `expected: to ${this.isNot ? "not " : ""}unpin ${msgString}\n`,
      "received: message pin = true",
    );
  }
}

exports.ToUnPinMessage = ToUnPinMessage;

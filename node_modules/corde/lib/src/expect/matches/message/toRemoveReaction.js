"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.ToRemoveReaction = void 0;

const errors_1 = require("../../../errors");

const utils_1 = require("../../../utils");

const expectTest_1 = require("../expectTest");

class ToRemoveReaction extends expectTest_1.ExpectTest {
  constructor(params) {
    super({ ...params, testName: "toRemoveReaction" });
  }

  async action(emojis, messageIdentifier) {
    if (
      messageIdentifier != null &&
      utils_1.typeOf(messageIdentifier) !== "object" &&
      utils_1.typeOf(messageIdentifier) !== "string"
    ) {
      return this.createReport(
        "expect: message data to be null, undefined, string or an object with id or text properties\n",
        `received: ${utils_1.typeOf(messageIdentifier)}`,
      );
    }

    if (!emojis || !Array.isArray(emojis)) {
      return this.createReport(
        "expected: emojis parameter to be an array with string or objects\n",
        `received: ${utils_1.typeOf(emojis)}`,
      );
    }

    try {
      await this.sendCommandMessage();
    } catch (error) {
      return this.createFailedTest(error.message);
    }

    let reactionsWithAuthors;

    try {
      const emojiLike = emojis.map((e) => {
        if (typeof e === "string") {
          return {
            name: e,
          };
        }

        return e;
      });

      const _messageData =
        typeof messageIdentifier === "string"
          ? {
              id: messageIdentifier,
            }
          : messageIdentifier;

      reactionsWithAuthors = await this.cordeBot.events.onceMessageReactionsRemove({
        emojis: emojiLike,
        messageIdentifier: _messageData,
        timeout: this.timeOut,
        channelId: this.channelId,
      });
    } catch (error) {
      var _error$data;

      if (this.isNot) {
        return this.createPassTest();
      }

      if (
        error instanceof errors_1.TimeoutError &&
        (_error$data = error.data) !== null &&
        _error$data !== void 0 &&
        _error$data.length
      ) {
        const _emojisReturned = reactionsFromResponse(error.data);

        return this.createReport(
          `expected: to remove reactions ${stringifyReactionToPrint(emojis)}\n`,
          `received: ${_emojisReturned}`,
        );
      }

      return this.createReport(
        `expected: to remove reactions ${stringifyReactionToPrint(emojis)}\n`,
        "received: no reaction was removed to message",
      );
    }

    this.hasPassed = true;
    this.invertHasPassedIfIsNot();

    if (this.hasPassed) {
      return this.createPassTest();
    }

    const emojisReturned = reactionsFromResponse(reactionsWithAuthors);
    return this.createReport(
      `expected: ${this.isNot ? "not " : ""}to remove reactions ${stringifyReactionToPrint(
        emojis,
      )}\n`,
      `received: ${emojisReturned}`,
    );
  }
}

exports.ToRemoveReaction = ToRemoveReaction;

function reactionsFromResponse(reactionsWithAuthors) {
  const emojis = reactionsWithAuthors.map((r) => r[0].emoji);
  return emojis.map((e) => e.name).join(", ");
}

function stringifyReactionToPrint(emojis) {
  return emojis
    .map((e) => {
      if (typeof e !== "string") {
        if (e.id) {
          return e.id;
        }

        return e.name;
      }

      return e;
    })
    .join(", ");
}

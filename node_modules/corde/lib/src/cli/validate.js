"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.validate = void 0;

const tslib_1 = require("tslib");

const chalk_1 = tslib_1.__importDefault(require("chalk"));

const errors_1 = require("../errors");

const utils_1 = require("../utils");

async function validate(configs) {
  if (!configs) {
    throw new errors_1.FileError(chalk_1.default.red("● configs not informed."));
  }

  const errors = [];
  addToErrorsIfPropertyIsMissing(configs.botPrefix, errors, "bot prefix");
  addToErrorsIfPropertyIsMissing(configs.botTestId, errors, "bot test ID");
  addToErrorsIfPropertyIsMissing(configs.channelId, errors, "channel ID");
  addToErrorsIfPropertyIsMissing(configs.cordeBotToken, errors, "corde token");
  addToErrorsIfPropertyIsMissing(configs.guildId, errors, "guild ID");
  addToErrorsIfPropertyIsMissing(configs.botToken, errors, "bot test token");
  await validatePaths(configs.testMatches, errors);
  let errorsString = "";

  if (errors.length > 0) {
    errorsString = chalk_1.default.red("\n● Corde validation report:\n  ");

    if (errors.length === 1) {
      errorsString += chalk_1.default.red("an required property is missing in config file:\n");
      buildMissingPropertiesErrorAndThrow(errorsString, errors);
    }

    if (errors.length > 1) {
      errorsString += chalk_1.default.red("some required properties are missing in config file\n");
      buildMissingPropertiesErrorAndThrow(errorsString, errors);
    }
  }
}

exports.validate = validate;

async function validatePaths(pathsDir, errors) {
  var _pathsDir;

  pathsDir =
    (_pathsDir = pathsDir) === null || _pathsDir === void 0 ? void 0 : _pathsDir.filter((p) => p);

  if (!pathsDir || pathsDir.length === 0) {
    errors.push("No test files informed." + chalk_1.default.cyan("(testMatches)"));
    return;
  }

  for (const pathDir of pathsDir) {
    const files = await utils_1.utils.getFiles(pathDir);

    if (files.length === 0) {
      errors.push(`path: ${pathDir} does not exists`);
    }
  }
}

function addToErrorsIfPropertyIsMissing(value, errors, message) {
  if (utils_1.stringIsNullOrEmpty(value)) {
    errors.push(message);
  }
}

function buildMissingPropertiesErrorAndThrow(errorString, erros) {
  erros.forEach((error) => (errorString += `\n    ${chalk_1.default.red(`- ${error}`)}`));
  errorString += "\n";
  throw new errors_1.PropertyError(errorString);
}
